package main

// rootfs2vhd is a simple utility to convert rootfs.tar.gz generated by
// the Microsoft/opengcs repos build.ps1 script to rootfs.vhd which LCOW
// can use for the root filesystem added on VPMem (as opposed to an initrd).
//
// It's not pretty, but enough to get the job done. It does require
// the Hyper-V RSAT to be installed for shelling out to New-VHD.

import (
	"bufio"
	"bytes"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"strings"

	"github.com/Microsoft/hcsshim/internal/schema2"
	"github.com/Microsoft/hcsshim/internal/uvm"
	"github.com/Microsoft/hcsshim/internal/wclayer"
	"github.com/sirupsen/logrus"
	"github.com/urfave/cli"
)

var (
	debug = false
	pause = false
)

func main() {

	app := cli.NewApp()
	cwd, _ := filepath.Abs("./")

	app.Flags = []cli.Flag{
		cli.StringFlag{
			Name:  "i",
			Usage: "Full path to .tar.gz of the root file system to be converted",
			Value: cwd + `\rootfs.tar.gz`,
		},
		cli.StringFlag{
			Name:  "o",
			Usage: "Full path to output filename",
			Value: cwd + `\rootfs.vhd`,
		},
		cli.IntFlag{
			Name:  "s",
			Usage: "Size in MB of the new VHD",
			Value: 19,
		},
		cli.BoolFlag{
			Name:  "D",
			Usage: "Debug mode",
		},
		cli.BoolFlag{
			Name:  "P",
			Usage: "Pause when complete but before tearing down the utility VM",
		},
	}
	app.Action = func(c *cli.Context) {
		rootfs2vhd(c)
	}
	fmt.Printf("\nrootfs2vhd: Converts an LCOW root filesystem tar.gz to a VHD\n\n")
	if err := app.Run(os.Args); err != nil {
		os.Exit(-1)
	}
}

func rootfs2vhd(c *cli.Context) {
	sourceRootFS := c.String("i")
	destFile := c.String("o")
	debug = c.Bool("D")
	pause = c.Bool("P")

	if debug {
		logrus.SetLevel(logrus.DebugLevel)
		logrus.SetFormatter(&logrus.TextFormatter{FullTimestamp: true})
	}

	if _, err := os.Stat(sourceRootFS); err != nil {
		fmt.Fprintf(os.Stderr, "%s not found\n", sourceRootFS)
		os.Exit(-1)
	}

	if _, err := os.Stat(destFile); err == nil {
		fmt.Fprintf(os.Stderr, "%s exists. Not overwriting\n", destFile)
		os.Exit(-1)
	}

	fmt.Printf("- Creating %s...\n", destFile)
	if _, err := exec.Command(`powershell`, `-command`, fmt.Sprintf(`New-VHD %s -SizeBytes %dMB -fixed`, destFile, c.Int("s"))).Output(); err != nil {
		fmt.Fprintf(os.Stderr, string(err.(*exec.ExitError).Stderr))
		os.Exit(-1)
	}

	fmt.Println("- Creating an LCOW utility VM...")
	lcowUVM, err := uvm.Create(&uvm.UVMOptions{OperatingSystem: "linux", ID: "rootfs2vhd"})
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to create utility VM: %s", err)
		os.Exit(-1)
	}

	fmt.Println("- Starting it....")
	if err := lcowUVM.Start(); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to start utility VM: %s", err)
		os.Exit(-1)
	}

	fmt.Printf("- Adding %s as read-only...\n", filepath.Dir(sourceRootFS))
	if err := lcowUVM.AddPlan9(filepath.Dir(sourceRootFS), `/fssource`, schema2.VPlan9FlagReadOnly); err != nil {
		fmt.Fprintf(os.Stderr, "failed to add %s: %s", filepath.Dir(sourceRootFS), err)
		lcowUVM.Terminate()
		lcowUVM.Wait()
		os.Exit(-1)
	}

	fmt.Printf("- Granting access to %s...\n", destFile)
	if err := wclayer.GrantVmAccess(lcowUVM.ID(), destFile); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to grant access: %s", err)
		lcowUVM.Terminate()
		lcowUVM.Wait()
		os.Exit(-1)
	}

	fmt.Println("- Hot-adding SCSI disk...")
	controller, lun, err := lcowUVM.AddSCSI(destFile, "") // No destination as not formatted
	if err != nil {
		fmt.Fprintf(os.Stderr, "Failed to add SCSI: %s", err)
		lcowUVM.Terminate()
		lcowUVM.Wait()
		os.Exit(-1)
	}
	fmt.Printf("- Added at SCSI %d:%d\n", controller, lun)

	uvmCommand(lcowUVM, []string{"test", "-d", fmt.Sprintf("/sys/bus/scsi/devices/%d:0:0:%d", controller, lun)})
	device := fmt.Sprintf(`/dev/%s`, strings.TrimSpace(uvmCommand(lcowUVM, []string{"ls", fmt.Sprintf("/sys/bus/scsi/devices/%d:0:0:%d/block", controller, lun)})))
	fmt.Printf("- Located at %s\n", device)

	fmt.Printf("- Formatting ext4...\n")
	uvmCommand(lcowUVM, []string{"mkfs.ext4", "-q", "-E", "lazy_itable_init=1", "-O", `^has_journal,sparse_super2,uninit_bg,^resize_inode`, device})

	fmt.Printf("- Extracting %s...\n", filepath.Base(sourceRootFS))
	uvmCommand(lcowUVM, []string{"mkdir", "/target"})
	uvmCommand(lcowUVM, []string{"mount", device, "/target"})
	uvmCommand(lcowUVM, []string{"rm", "-rf", "/target/lost+found"})
	uvmCommand(lcowUVM, []string{"sh", "-c", fmt.Sprintf(`cd /target; gzip -dc /fssource/%s | tar x`, filepath.Base(sourceRootFS))})
	fmt.Println("- Extract complete!")
	fmt.Printf("\n%s\n", uvmCommand(lcowUVM, []string{"df", "/target"}))
	possiblePause()

	fmt.Println("- Removing SCSI disk...")
	if err := lcowUVM.RemoveSCSI(destFile); err != nil {
		fmt.Fprintf(os.Stderr, "Failed to remove SCSI: %s", err)
		lcowUVM.Terminate()
		lcowUVM.Wait()
		os.Exit(-1)
	}

	lcowUVM.Terminate()

	fmt.Printf("\nSuccess\n")
	os.Exit(0)
}

func uvmCommand(lcowUVM *uvm.UtilityVM, args []string) string {
	args = append([]string{"hcsdiag", "exec", "-uvm", lcowUVM.ID()}, args...)
	cmd := exec.Command(args[0], args[1:]...)
	var o, e bytes.Buffer
	cmd.Stdout = &o
	cmd.Stderr = &e
	err := cmd.Run()
	if err != nil {
		fmt.Fprintf(os.Stderr, "%+v failed:\n%s\n%s)", args, err, e.String())
		possiblePause()
		lcowUVM.Terminate()
		os.Exit(-1)
	}
	return o.String()
}

func possiblePause() {
	if pause {
		fmt.Print("Press 'Enter' to continue...")
		bufio.NewReader(os.Stdin).ReadBytes('\n')
	}
}
